/**
 * Ask Expert Orchestration API Endpoint
 *
 * Connects to the unified LangGraph orchestrator and streams real-time updates
 * via Server-Sent Events (SSE) for all 5 consultation modes.
 *
 * @route POST /api/ask-expert/orchestrate
 * @see unified-langgraph-orchestrator.ts for LangGraph implementation
 * @see useLangGraphOrchestration.ts for client-side hook
 */

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { unifiedOrchestrator, OrchestrationMode } from '@/features/chat/services/unified-langgraph-orchestrator';

// ===== TYPE DEFINITIONS =====

interface OrchestrationRequest {
  query: string;
  mode: OrchestrationMode;
  userId: string;
  conversationId?: string;
  manualAgentId?: string | null;
  persistentAgentId?: string | null;
  humanApproval?: boolean;
  templateId?: string;
  metadata?: Record<string, any>;
}

// ===== SSE HELPER FUNCTIONS =====

/**
 * Create Server-Sent Events response
 */
function createSSEResponse() {
  const encoder = new TextEncoder();
  let controller: ReadableStreamDefaultController;

  const stream = new ReadableStream({
    start(ctrl) {
      controller = ctrl;
    },
    cancel() {
      console.log('SSE stream cancelled by client');
    }
  });

  const sendEvent = (event: any) => {
    const data = `data: ${JSON.stringify(event)}\n\n`;
    controller.enqueue(encoder.encode(data));
  };

  const close = () => {
    try {
      const data = `data: [DONE]\n\n`;
      controller.enqueue(encoder.encode(data));
      controller.close();
    } catch (error) {
      console.error('Error closing SSE stream:', error);
    }
  };

  return { stream, sendEvent, close };
}

// ===== MAIN HANDLER =====

export async function POST(request: NextRequest) {
  try {
    // Parse request body
    const body: OrchestrationRequest = await request.json();

    // Validate required fields
    if (!body.query || !body.mode || !body.userId) {
      return NextResponse.json(
        { error: 'Missing required fields: query, mode, userId' },
        { status: 400 }
      );
    }

    // Validate and convert mode from string to enum
    const modeString = body.mode as unknown as string;
    const validModes: Record<string, OrchestrationMode> = {
      'query_automatic': OrchestrationMode.QUERY_AUTOMATIC,
      'query_manual': OrchestrationMode.QUERY_MANUAL,
      'chat_automatic': OrchestrationMode.CHAT_AUTOMATIC,
      'chat_manual': OrchestrationMode.CHAT_MANUAL,
      'agent': OrchestrationMode.AGENT
    };

    if (!validModes[modeString]) {
      return NextResponse.json(
        { error: `Invalid mode. Must be one of: ${Object.keys(validModes).join(', ')}` },
        { status: 400 }
      );
    }

    const orchestratorMode = validModes[modeString];

    // Initialize Supabase client
    const supabase = await createClient();

    // Verify user exists
    const { data: user, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // Create SSE response
    const { stream, sendEvent, close } = createSSEResponse();

    // Execute orchestration in background
    (async () => {
      try {
        console.log(`üöÄ Starting ${body.mode} orchestration for user ${body.userId}`);

        // Send initial event
        sendEvent({
          type: 'start',
          timestamp: new Date().toISOString()
        });

        // Call unified LangGraph orchestrator with streaming
        // Note: orchestratorMode was already converted from string to enum above
        const result = await unifiedOrchestrator.execute({
          query: body.query,
          mode: orchestratorMode,
          userId: body.userId,
          conversationId: body.conversationId,
          manualAgentId: body.manualAgentId,
          persistentAgentId: body.persistentAgentId,
          humanApproval: body.humanApproval,
          metadata: body.metadata
        });

        // Send workflow step events
        if (result.logs && result.logs.length > 0) {
          for (let i = 0; i < result.logs.length; i++) {
            const log = result.logs[i];
            const stepId = extractStepIdFromLog(log);

            if (stepId) {
              sendEvent({
                type: 'workflow_step',
                stepId,
                status: i < result.logs.length - 1 ? 'completed' : 'running',
                progress: 100,
                timestamp: new Date().toISOString()
              });
            }
          }
        }

        // Send final response (type assertion to handle LangGraph state)
        const response = (result as any).response || 'No response generated';
        const conversationId = (result as any).conversationId || body.conversationId || generateConversationId();

        sendEvent({
          type: 'response_complete',
          response,
          conversationId,
          agents: ((result as any).selectedAgents || []).map((agent: any) => ({
            id: agent.id,
            name: agent.name,
            contribution: agent.systemPrompt || agent.description
          })),
          sources: (result as any).sources || [],
          taskPlan: (result as any).taskPlan,
          checkpoints: (result as any).checkpoints,
          timestamp: new Date().toISOString()
        });

        // Send metrics
        sendEvent({
          type: 'metrics',
          tokensGenerated: (result as any).metadata?.tokenCount || 0,
          tokensPerSecond: calculateTokensPerSecond((result as any).metadata?.tokenCount || 0, (result as any).metadata?.duration || 1),
          elapsedTime: (result as any).metadata?.duration || 0,
          timestamp: new Date().toISOString()
        });

        console.log(`‚úÖ Orchestration completed successfully`);

      } catch (error: any) {
        console.error('‚ùå Orchestration error:', error);

        sendEvent({
          type: 'error',
          message: error.message || 'An error occurred during orchestration',
          timestamp: new Date().toISOString()
        });
      } finally {
        // Close SSE stream
        close();
      }
    })();

    // Return SSE response
    return new NextResponse(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache, no-transform',
        'Connection': 'keep-alive',
        'X-Accel-Buffering': 'no' // Disable nginx buffering
      }
    });

  } catch (error: any) {
    console.error('API error:', error);

    return NextResponse.json(
      { error: error.message || 'Internal server error' },
      { status: 500 }
    );
  }
}

// ===== HELPER FUNCTIONS =====

/**
 * Extract step ID from log message
 */
function extractStepIdFromLog(log: string): string | null {
  // Patterns to match step IDs in logs
  const patterns = [
    /‚úÖ\s+(\w+)\s+completed/i,
    /üîÑ\s+(\w+):/i,
    /Node:\s+(\w+)/i
  ];

  for (const pattern of patterns) {
    const match = log.match(pattern);
    if (match && match[1]) {
      return match[1].toLowerCase();
    }
  }

  return null;
}

/**
 * Calculate tokens per second
 */
function calculateTokensPerSecond(tokens: number, durationMs: number): number {
  if (durationMs === 0) return 0;
  return (tokens / durationMs) * 1000;
}

/**
 * Generate conversation ID
 */
function generateConversationId(): string {
  return `conv_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
}

// ===== CHECKPOINT ENDPOINTS =====

// NOTE: Checkpoint approve/reject functions removed
// They should be implemented in separate route files:
// - /api/ask-expert/checkpoint/approve/route.ts
// - /api/ask-expert/checkpoint/reject/route.ts
