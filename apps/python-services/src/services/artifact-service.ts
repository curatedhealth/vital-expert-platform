/**
 * Artifact Generation Service
 * Handles creation, export, and management of AI-generated artifacts
 */

import type { Artifact, ArtifactType, ExportFormat } from '@/types/chat.types';

export interface ArtifactTemplate {
  type: ArtifactType;
  title: string;
  description: string;
  template: string;
  variables: string[];
}

export class ArtifactService {
  private static instance: ArtifactService;
  private templates: Map<string, ArtifactTemplate> = new Map();

  constructor() {
    this.initializeTemplates();
  }

  static getInstance(): ArtifactService {
    if (!ArtifactService.instance) {
      ArtifactService.instance = new ArtifactService();
    }
    return ArtifactService.instance;
  }

  private initializeTemplates() {
    // Clinical Protocol Template
    this.templates.set('clinical-protocol', {
      type: 'clinical-protocol',
      title: 'Clinical Trial Protocol',
      description: 'Standardized clinical trial protocol with regulatory compliance',
      template: `# Clinical Trial Protocol

## Study Title
{{studyTitle}}

## Protocol Summary
**Protocol Number:** {{protocolNumber}}
**Study Phase:** {{studyPhase}}
**Primary Indication:** {{indication}}
**Study Design:** {{studyDesign}}

## Primary Objectives
{{primaryObjectives}}

## Secondary Objectives
{{secondaryObjectives}}

## Study Population
### Inclusion Criteria
{{inclusionCriteria}}

### Exclusion Criteria
{{exclusionCriteria}}

## Study Procedures
{{studyProcedures}}

## Safety Considerations
{{safetyConsiderations}}

## Statistical Analysis Plan
{{statisticalPlan}}

## Regulatory Considerations
{{regulatoryConsiderations}}

---
Generated by VITAL AI Clinical Protocol Generator
Date: {{generationDate}}`,
      variables: [
        'studyTitle',
        'protocolNumber',
        'studyPhase',
        'indication',
        'studyDesign',
        'primaryObjectives',
        'secondaryObjectives',
        'inclusionCriteria',
        'exclusionCriteria',
        'studyProcedures',
        'safetyConsiderations',
        'statisticalPlan',
        'regulatoryConsiderations',
        'generationDate'
      ]
    });

    // Regulatory Document Template
    this.templates.set('regulatory-document', {
      type: 'regulatory-document',
      title: 'FDA Submission Document',
      description: 'FDA regulatory submission document template',
      template: `# {{documentType}} - FDA Submission

## Executive Summary
{{executiveSummary}}

## Device/Product Information
**Product Name:** {{productName}}
**Classification:** {{classification}}
**Indication for Use:** {{indicationForUse}}

## Regulatory Pathway
{{regulatoryPathway}}

## Clinical Evidence
{{clinicalEvidence}}

## Risk Assessment
{{riskAssessment}}

## Quality Management
{{qualityManagement}}

## Labeling
{{labeling}}

## Conclusion
{{conclusion}}

---
Generated by VITAL AI Regulatory Document Generator
Compliance Level: {{complianceLevel}}
Date: {{generationDate}}`,
      variables: [
        'documentType',
        'executiveSummary',
        'productName',
        'classification',
        'indicationForUse',
        'regulatoryPathway',
        'clinicalEvidence',
        'riskAssessment',
        'qualityManagement',
        'labeling',
        'conclusion',
        'complianceLevel',
        'generationDate'
      ]
    });

    // Research Proposal Template
    this.templates.set('research-proposal', {
      type: 'research-proposal',
      title: 'Clinical Research Proposal',
      description: 'Academic research proposal for clinical studies',
      template: `# {{proposalTitle}}

## Abstract
{{abstract}}

## Background and Rationale
{{background}}

## Research Questions
### Primary Research Question
{{primaryQuestion}}

### Secondary Research Questions
{{secondaryQuestions}}

## Methodology
### Study Design
{{studyDesign}}

### Participants
{{participants}}

### Data Collection
{{dataCollection}}

### Statistical Analysis
{{statisticalAnalysis}}

## Timeline
{{timeline}}

## Budget
{{budget}}

## Ethical Considerations
{{ethicalConsiderations}}

## Expected Outcomes
{{expectedOutcomes}}

## References
{{references}}

---
Generated by VITAL AI Research Proposal Generator
Date: {{generationDate}}`,
      variables: [
        'proposalTitle',
        'abstract',
        'background',
        'primaryQuestion',
        'secondaryQuestions',
        'studyDesign',
        'participants',
        'dataCollection',
        'statisticalAnalysis',
        'timeline',
        'budget',
        'ethicalConsiderations',
        'expectedOutcomes',
        'references',
        'generationDate'
      ]
    });

    // Data Analysis Template
    this.templates.set('data-analysis', {
      type: 'data-analysis',
      title: 'Clinical Data Analysis Report',
      description: 'Statistical analysis report for clinical data',
      template: `# Clinical Data Analysis Report

## Analysis Summary
**Study:** {{studyName}}
**Analysis Type:** {{analysisType}}
**Date:** {{analysisDate}}

## Dataset Description
{{datasetDescription}}

## Statistical Methods
{{statisticalMethods}}

## Results
### Primary Endpoints
{{primaryResults}}

### Secondary Endpoints
{{secondaryResults}}

### Safety Analysis
{{safetyResults}}

## Statistical Tables
{{statisticalTables}}

## Figures
{{figures}}

## Discussion
{{discussion}}

## Conclusions
{{conclusions}}

## Code Repository
\`\`\`{{codeLanguage}}
{{analysisCode}}
\`\`\`

---
Generated by VITAL AI Data Analysis Engine
Statistical Package: {{statisticalPackage}}
Date: {{generationDate}}`,
      variables: [
        'studyName',
        'analysisType',
        'analysisDate',
        'datasetDescription',
        'statisticalMethods',
        'primaryResults',
        'secondaryResults',
        'safetyResults',
        'statisticalTables',
        'figures',
        'discussion',
        'conclusions',
        'codeLanguage',
        'analysisCode',
        'statisticalPackage',
        'generationDate'
      ]
    });
  }

  async generateArtifact(
    type: ArtifactType,
    variables: Record<string, string>,
    title?: string,
    description?: string
  ): Promise<Artifact> {

    if (!template) {
      throw new Error(`No template found for artifact type: ${type}`);
    }

    // Replace template variables

    for (const [key, value] of Object.entries(variables)) {

      content = content.replace(regex, value || `[${key}]`);
    }

    // Add generation timestamp
    content = content.replace(/{{generationDate}}/g, new Date().toISOString());

    const artifact: Artifact = {
      id: `artifact-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      type,
      title: title || template.title,
      description: description || template.description,
      content,
      size: new Blob([content]).size,
      createdAt: new Date(),
      confidence: 0.95, // High confidence for template-based generation
      metadata: {
        language: type === 'code-snippet' ? variables.language : 'markdown',
        version: '1.0',
        tags: [type, 'ai-generated', 'vital-ai']
      }
    };

    return artifact;
  }

  async exportArtifact(artifact: Artifact, format: ExportFormat): Promise<Blob> {

    switch (format) {
      case 'pdf':
        return this.exportToPDF(content, filename);

      case 'docx':
        return this.exportToDocx(content, filename);

      case 'md':
        return new Blob([content], { type: 'text/markdown' });

      case 'txt':
        return new Blob([content], { type: 'text/plain' });

      case 'html':
        return this.exportToHTML(content, artifact.title);

      case 'json':

          id: artifact.id,
          title: artifact.title,
          type: artifact.type,
          content: artifact.content,
          createdAt: artifact.createdAt,
          metadata: artifact.metadata
        };
        return new Blob([JSON.stringify(jsonData, null, 2)], {
          type: 'application/json'
        });

      case 'xlsx':
        return this.exportToExcel(content);

      case 'csv':
        return this.exportToCSV(content);

      case 'latex':
        return this.exportToLatex(content);

      default:
        throw new Error(`Unsupported export format: ${format}`);
    }
  }

  private getFilename(artifact: Artifact, format: ExportFormat): string {

      .toLowerCase()
      .replace(/[^a-z0-9]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');

    return `${sanitizedTitle}.${format}`;
  }

  private async exportToPDF(content: string, filename: string): Promise<Blob> {
    // In a real implementation, you would use a PDF generation library
    // For now, return a mock PDF

1 0 obj
<< /Type /Catalog /Pages 2 0 R >>
endobj
2 0 obj
<< /Type /Pages /Kids [3 0 R] /Count 1 >>
endobj
3 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Resources << /Font << /F1 4 0 R >> >> /Contents 5 0 R >>
endobj
4 0 obj
<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>
endobj
5 0 obj
<< /Length 100 >>
stream
BT
/F1 12 Tf
50 750 Td
(${content.substring(0, 100)}...) Tj
ET
endstream
endobj
xref
0 6
0000000000 65535 f
0000000010 00000 n
0000000053 00000 n
0000000110 00000 n
0000000252 00000 n
0000000320 00000 n
trailer
<< /Size 6 /Root 1 0 R >>
startxref
470
%%EOF`;

    return new Blob([pdfContent], { type: 'application/pdf' });
  }

  private async exportToDocx(content: string, filename: string): Promise<Blob> {
    // Mock DOCX export - in production use docx library

<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <w:body>
    <w:p>
      <w:r>
        <w:t>${content}</w:t>
      </w:r>
    </w:p>
  </w:body>
</w:document>`;

    return new Blob([docxContent], {
      type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    });
  }

  private async exportToHTML(content: string, title: string): Promise<Blob> {

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        .container { max-width: 800px; margin: 0 auto; padding: 20px; }
        pre { background: #f5f5f5; padding: 10px; border-radius: 4px; overflow-x: auto; }
        code { background: #f5f5f5; padding: 2px 4px; border-radius: 2px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>${title}</h1>
        <pre>${content}</pre>
    </div>
</body>
</html>`;

    return new Blob([htmlContent], { type: 'text/html' });
  }

  private async exportToExcel(content: string): Promise<Blob> {
    // Mock Excel export - in production use xlsx library

    return new Blob([csvData], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });
  }

  private async exportToCSV(content: string): Promise<Blob> {

    return new Blob([csvData], { type: 'text/csv' });
  }

  private async exportToLatex(content: string): Promise<Blob> {

\\usepackage[utf8]{inputenc}
\\usepackage{amsmath}
\\usepackage{graphicx}

\\title{${content.split('\n')[0].replace('#', '').trim()}}
\\author{VITAL AI}
\\date{\\today}

\\begin{document}
\\maketitle

${content.replace(/^# /gm, '\\section{').replace(/^## /gm, '\\subsection{').replace(/^### /gm, '\\subsubsection{')}

\\end{document}`;

    return new Blob([latexContent], { type: 'application/x-latex' });
  }

  private convertToCSV(content: string): string {
    // Simple conversion - in production, implement proper parsing

    return lines.map(line => `"${line.replace(/"/g, '""')}"`).join('\n');
  }

  downloadBlob(blob: Blob, filename: string): void {

    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  async shareArtifact(artifact: Artifact): Promise<string> {
    // Mock sharing functionality - in production, integrate with sharing service

      title: artifact.title,
      text: artifact.description || 'Generated by VITAL AI',
      url: typeof window !== 'undefined' ? `${window.location.origin}/artifacts/${artifact.id}` : `/artifacts/${artifact.id}`
    };

    if (navigator.share && navigator.canShare(shareData)) {
      await navigator.share(shareData);
      return 'shared-native';
    } else {
      // Fallback to copying link

      await navigator.clipboard.writeText(shareUrl);
      return shareUrl;
    }
  }
}

export const __artifactService = ArtifactService.getInstance();