/**
 * VITAL Path Security Vulnerability Scanner
 * Comprehensive vulnerability detection for healthcare applications
 */

import { execSync } from 'child_process';
import * as fs from 'fs/promises';
import * as path from 'path';

// Security vulnerability patterns
const VULNERABILITY_PATTERNS = {
  CODE_INJECTION: [
    /eval\s*\(/gi,
    /Function\s*\(/gi,
    /setTimeout\s*\(\s*['"]/gi,
    /setInterval\s*\(\s*['"]/gi,
    /new\s+Function\s*\(/gi,
    /vm\.runInThisContext/gi,
    /vm\.runInNewContext/gi
  ],

  SQL_INJECTION: [
    /query\s*\(\s*[^?]/gi,
    /execute\s*\(\s*[^?]/gi,
    /rawQuery/gi,
    /\$\{.*\}.*sql/gi,
    /SELECT.*\+.*FROM/gi,
    /INSERT.*\+.*VALUES/gi,
    /UPDATE.*SET.*\+/gi,
    /DELETE.*WHERE.*\+/gi
  ],

  // XSS vulnerabilities
  XSS_VULNERABILITIES: [
    /innerHTML\s*=/gi,
    /outerHTML\s*=/gi,
    /document\.write\s*\(/gi,
    /dangerouslySetInnerHTML/gi,
    /v-html/gi,
    /\[innerHTML\]/gi,
    /<script.*>/gi
  ],

  // Hardcoded secrets
  HARDCODED_SECRETS: [
    /password\s*=\s*['"]/gi,
    /api[_-]?key\s*=\s*['"]/gi,
    /secret\s*=\s*['"]/gi,
    /token\s*=\s*['"]/gi,
    /private[_-]?key\s*=\s*['"]/gi,
    /access[_-]?token\s*=\s*['"]/gi,
    /database[_-]?url\s*=\s*['"]/gi,
    /connection[_-]?string\s*=\s*['"]/gi
  ],

  // Insecure cryptography
  CRYPTO_VULNERABILITIES: [
    /MD5/gi,
    /SHA1/gi,
    /DES/gi,
    /RC4/gi,
    /Math\.random\(\)/gi,
    /crypto\.pseudoRandomBytes/gi,
    /\bcrypto-js\b/gi
  ],

  // Healthcare-specific security patterns
  PHI_EXPOSURE: [
    /console\.log.*patient/gi,
    /console\.log.*ssn/gi,
    /console\.log.*medical/gi,
    /alert.*patient/gi,
    /localStorage\.setItem.*patient/gi,
    /sessionStorage\.setItem.*medical/gi
  ],

  // Insecure HTTP patterns
  INSECURE_HTTP: [
    /http:\/\/(?!localhost|127\.0\.0\.1)/gi,
    /fetch\s*\(\s*['"']http:/gi,
    /axios\s*\(\s*['"']http:/gi,
    /request\s*\(\s*['"']http:/gi
  ],

  // File system vulnerabilities
  FILE_TRAVERSAL: [
    /\.\.\/\.\.\//gi,
    /path\.join\s*\(.*\.\.\//gi,
    /fs\.readFile\s*\(.*\+/gi,
    /fs\.writeFile\s*\(.*\+/gi,
    /require\s*\(.*\+/gi
  ],

  // Command injection
  COMMAND_INJECTION: [
    /exec\s*\(/gi,
    /execSync\s*\(/gi,
    /spawn\s*\(/gi,
    /system\s*\(/gi,
    /shell_exec/gi,
    /passthru/gi
  ],

  // Insecure configurations
  INSECURE_CONFIG: [
    /NODE_ENV.*production.*false/gi,
    /secure:\s*false/gi,
    /httpOnly:\s*false/gi,
    /sameSite:\s*'none'/gi,
    /cors\s*\(\s*\)/gi,
    /trust\s+proxy.*true/gi
  ]
};

// Healthcare-specific compliance patterns
const COMPLIANCE_PATTERNS = {
  HIPAA_VIOLATIONS: [
    /patient.*name.*console/gi,
    /medical.*record.*localStorage/gi,
    /ssn.*sessionStorage/gi,
    /phi.*unencrypted/gi,
    /health.*data.*log/gi
  ],

  FDA_COMPLIANCE: [
    /device.*data.*unvalidated/gi,
    /clinical.*trial.*unauthorized/gi,
    /medical.*algorithm.*unverified/gi,
    /diagnostic.*result.*unsafe/gi
  ],

  GDPR_VIOLATIONS: [
    /personal.*data.*without.*consent/gi,
    /user.*tracking.*no.*opt.*out/gi,
    /data.*retention.*unlimited/gi,
    /cookie.*no.*consent/gi
  ]
};

interface SecurityVulnerability {
  type: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  file: string;
  line: number;
  code: string;
  recommendation: string;
  cve?: string;
  compliance?: string[];
}

interface SecurityScanResult {
  summary: {
    totalFiles: number;
    totalVulnerabilities: number;
    criticalVulnerabilities: number;
    highVulnerabilities: number;
    mediumVulnerabilities: number;
    lowVulnerabilities: number;
    complianceViolations: number;
  };
  vulnerabilities: SecurityVulnerability[];
  complianceReport: {
    hipaaCompliant: boolean;
    fdaCompliant: boolean;
    gdprCompliant: boolean;
    issues: string[];
  };
  recommendations: string[];
}

export class SecurityVulnerabilityScanner {
  private projectRoot: string;
  private scanResults: SecurityScanResult;

  constructor(projectRoot: string = process.cwd()) {
    this.projectRoot = projectRoot;
    this.scanResults = {
      summary: {
        totalFiles: 0,
        totalVulnerabilities: 0,
        criticalVulnerabilities: 0,
        highVulnerabilities: 0,
        mediumVulnerabilities: 0,
        lowVulnerabilities: 0,
        complianceViolations: 0
      },
      vulnerabilities: [],
      complianceReport: {
        hipaaCompliant: true,
        fdaCompliant: true,
        gdprCompliant: true,
        issues: []
      },
      recommendations: []
    };
  }

  async scanProject(): Promise<SecurityScanResult> {
    // // Scan source code
    await this.scanSourceCode();

    // Scan dependencies
    await this.scanDependencies();

    // Scan configuration files
    await this.scanConfigurations();

    // Generate compliance report
    await this.generateComplianceReport();

    // Generate recommendations
    this.generateRecommendations();

    // Log summary
    this.logScanSummary();

    return this.scanResults;
  }

  private async scanSourceCode(): Promise<void> {
    const sourceFiles = await this.findSourceFiles();
    this.scanResults.summary.totalFiles = sourceFiles.length;

    for (const filePath of sourceFiles) {
      await this.scanFile(filePath);
    }
  }

  private async scanFile(filePath: string): Promise<void> {
    try {
      const content = await fs.readFile(filePath, 'utf-8');
      const lines = content.split('\n');

      // Scan for security patterns
      for (const [category, patterns] of Object.entries(VULNERABILITY_PATTERNS)) {
        for (const pattern of patterns) {
          lines.forEach((line, index) => {
            const matches = pattern.exec(line);
            if (matches) {
              const vulnerability = this.createVulnerability(
                category,
                filePath,
                index + 1,
                line.trim(),
                matches[0]
              );
              this.scanResults.vulnerabilities.push(vulnerability);
              this.updateSummary(vulnerability.severity);
            }
          });
        }
      }

      // Scan for healthcare compliance violations
      for (const [category, patterns] of Object.entries(COMPLIANCE_PATTERNS)) {
        for (const pattern of patterns) {
          lines.forEach((line, index) => {
            const matches = pattern.exec(line);
            if (matches) {
              const vulnerability = this.createVulnerability(
                category,
                filePath,
                index + 1,
                line.trim(),
                matches[0]
              );
              this.scanResults.vulnerabilities.push(vulnerability);
              this.scanResults.summary.complianceViolations++;
              this.updateComplianceReport(category);
            }
          });
        }
      }

    } catch (error) {
      // console.warn(`⚠️  Could not scan file: ${filePath}`);
    }
  }

  private async scanDependencies(): Promise<void> {
    try {
      // Run npm audit
      const { execSync } = require('child_process');
      const auditOutput = execSync('npm audit --json', {
        cwd: this.projectRoot,
        encoding: 'utf-8'
      });

      const auditData = JSON.parse(auditOutput);

      if (auditData.vulnerabilities) {
        for (const [packageName, vulnData] of Object.entries(auditData.vulnerabilities as unknown)) {
          const vuln = vulnData as any;
          const vulnerability: SecurityVulnerability = {
            type: 'DEPENDENCY_VULNERABILITY',
            severity: this.mapAuditSeverity(vuln.severity),
            description: `Vulnerable dependency: ${packageName}`,
            file: 'package.json',
            line: 1,
            code: `"${packageName}": "${vuln.range}"`,
            recommendation: `Update ${packageName} to version ${vuln.patched || 'latest'}`,
            cve: vuln.cve,
            compliance: ['SECURITY']
          };

          this.scanResults.vulnerabilities.push(vulnerability);
          this.updateSummary(vulnerability.severity);
        }
      }

      // console.log(`Found ${vulnerabilities.length} dependency vulnerabilities`);

    } catch (error) {
      // console.warn('⚠️  Could not run npm audit - dependencies not scanned');
    }
  }

  private async scanConfigurations(): Promise<void> {
    const configFiles = [
      'next.config.js',
      'next.config.ts',
      '.env',
      '.env.local',
      '.env.production',
      'docker-compose.yml',
      'Dockerfile'
    ];

    for (const configFile of configFiles) {
      const filePath = path.join(process.cwd(), configFile);
      try {
        await fs.access(filePath);
        await this.scanConfigFile(filePath);
      } catch {
        // File doesn't exist, skip
      }
    }
  }

  private async scanConfigFile(filePath: string): Promise<void> {
    try {

      // Check for insecure configurations

        { pattern: /DEBUG.*=.*true/gi, description: 'Debug mode enabled in production' },
        { pattern: /password.*=.*admin/gi, description: 'Default password detected' },
        { pattern: /secret.*=.*secret/gi, description: 'Default secret key detected' },
        { pattern: /ssl.*=.*false/gi, description: 'SSL disabled' },
        { pattern: /cors.*origin.*\*/gi, description: 'CORS allows all origins' }
      ];

      lines.forEach((line, index) => {
        insecurePatterns.forEach(({ pattern, description }) => {
          if (pattern.test(line)) {
            const vulnerability: SecurityVulnerability = {
              type: 'INSECURE_CONFIGURATION',
              severity: 'high',
              description,
              file: path.basename(filePath),
              line: index + 1,
              code: line.trim(),
              recommendation: 'Review and secure configuration settings',
              compliance: ['HIPAA', 'SECURITY']
            };

            this.scanResults.vulnerabilities.push(vulnerability);
            this.updateSummary('high');
          }
        });
      });

    } catch (error) {
      // console.warn(`⚠️  Could not scan config file: ${filePath}`);
    }
  }

  private createVulnerability(
    category: string,
    filePath: string,
    line: number,
    code: string,
    match: string
  ): SecurityVulnerability {
    const severityMap: Record<string, 'critical' | 'high' | 'medium' | 'low'> = {
      CODE_INJECTION: 'critical',
      SQL_INJECTION: 'critical',
      XSS_VULNERABILITIES: 'high',
      HARDCODED_SECRETS: 'high',
      CRYPTO_VULNERABILITIES: 'medium',
      PHI_EXPOSURE: 'critical',
      INSECURE_HTTP: 'medium',
      FILE_TRAVERSAL: 'high',
      COMMAND_INJECTION: 'critical',
      INSECURE_CONFIG: 'high'
    };

    const recommendations: Record<string, string> = {
      CODE_INJECTION: 'Avoid eval() and dynamic code execution. Use safer alternatives.',
      SQL_INJECTION: 'Use parameterized queries or ORM to prevent SQL injection.',
      XSS_VULNERABILITIES: 'Sanitize user input and use safe DOM manipulation methods.',
      HARDCODED_SECRETS: 'Move secrets to environment variables or secure key management.',
      CRYPTO_VULNERABILITIES: 'Use modern cryptographic algorithms (AES-256, SHA-256+).',
      PHI_EXPOSURE: 'Never log or expose PHI in client-side code or logs.',
      INSECURE_HTTP: 'Use HTTPS for all external communications.',
      FILE_TRAVERSAL: 'Validate and sanitize file paths. Use path.resolve().',
      COMMAND_INJECTION: 'Avoid executing user input as commands. Use safe alternatives.',
      INSECURE_CONFIG: 'Review and secure configuration settings for production.'
    };

    return {
      type: category,
      // eslint-disable-next-line security/detect-object-injection
      severity: severityMap[category] || 'medium',
      description: `${category.replace(/_/g, ' ').toLowerCase()} detected: ${match}`,
      file: path.relative(this.projectRoot, filePath),
      line,
      code,
      // eslint-disable-next-line security/detect-object-injection
      recommendation: recommendations[category] || 'Review and fix security issue',
      compliance: category.includes('PHI') ? ['HIPAA'] : ['SECURITY']
    };
  }

  private createComplianceViolation(
    category: string,
    filePath: string,
    line: number,
    code: string,
    match: string
  ): SecurityVulnerability {
    const complianceMap: Record<string, string[]> = {
      HIPAA_VIOLATIONS: ['HIPAA'],
      FDA_COMPLIANCE: ['FDA'],
      GDPR_VIOLATIONS: ['GDPR']
    };

    return {
      type: `COMPLIANCE_${category}`,
      severity: 'critical',
      description: `${category.replace(/_/g, ' ').toLowerCase()} detected: ${match}`,
      file: path.relative(this.projectRoot, filePath),
      line,
      code,
      recommendation: 'Review and ensure compliance with healthcare regulations',
      // eslint-disable-next-line security/detect-object-injection
      compliance: complianceMap[category] || ['COMPLIANCE']
    };
  }

  private updateSummary(severity: 'low' | 'medium' | 'high' | 'critical'): void {
    this.scanResults.summary.totalVulnerabilities++;

    switch (severity) {
      case 'critical':
        this.scanResults.summary.criticalVulnerabilities++;
        break;
      case 'high':
        this.scanResults.summary.highVulnerabilities++;
        break;
      case 'medium':
        this.scanResults.summary.mediumVulnerabilities++;
        break;
      case 'low':
        this.scanResults.summary.lowVulnerabilities++;
        break;
    }
  }

  private updateComplianceReport(category: string): void {
    if (category === 'HIPAA_VIOLATIONS') {
      this.scanResults.complianceReport.hipaaCompliant = false;
      this.scanResults.complianceReport.issues.push('HIPAA violations detected');
    }
    if (category === 'FDA_COMPLIANCE') {
      this.scanResults.complianceReport.fdaCompliant = false;
      this.scanResults.complianceReport.issues.push('FDA compliance issues detected');
    }
    if (category === 'GDPR_VIOLATIONS') {
      this.scanResults.complianceReport.gdprCompliant = false;
      this.scanResults.complianceReport.issues.push('GDPR violations detected');
    }
  }

  private async generateComplianceReport(): Promise<void> {
    // // Additional compliance checks

      this.checkHIPAACompliance(),
      this.checkFDACompliance(),
      this.checkGDPRCompliance()
    ];

    await Promise.all(complianceChecks);
  }

  private async checkHIPAACompliance(): Promise<void> {
    // Check for HIPAA-specific requirements

      'audit logging enabled',
      'data encryption at rest',
      'secure transmission protocols',
      'access controls implemented',
      'PHI handling procedures'
    ];

    // Implementation would check these requirements
    // For now, mark as compliant if no violations found
  }

  private async checkFDACompliance(): Promise<void> {
    // Check for FDA software validation requirements
    // Implementation would verify FDA 21 CFR Part 11 compliance
  }

  private async checkGDPRCompliance(): Promise<void> {
    // Check for GDPR data protection requirements
    // Implementation would verify GDPR Article 32 compliance
  }

  private generateRecommendations(): void {

    if (this.scanResults.summary.criticalVulnerabilities > 0) {
      recommendations.push('🚨 CRITICAL: Fix all critical vulnerabilities immediately before deployment');
    }

    if (this.scanResults.summary.highVulnerabilities > 0) {
      recommendations.push('⚠️  HIGH: Address high-severity vulnerabilities before production release');
    }

    if (!this.scanResults.complianceReport.hipaaCompliant) {
      recommendations.push('🏥 HIPAA: Ensure all PHI handling meets HIPAA requirements');
    }

    if (this.scanResults.summary.totalVulnerabilities > 50) {
      recommendations.push('📈 Consider implementing automated security testing in CI/CD pipeline');
    }

    recommendations.push('🔒 Implement regular security scans and penetration testing');
    recommendations.push('📚 Provide security training for development team');
    recommendations.push('🛡️  Set up security monitoring and incident response procedures');

    this.scanResults.recommendations = recommendations;
  }

  private logScanSummary(): void {
    const { summary } = this.scanResults;

    // // // // // // // // // // // // // if (this.scanResults.recommendations.length > 0) {
      // this.scanResults.recommendations.forEach(rec => {/* */});
    }

    // }

  private async findSourceFiles(): Promise<string[]> {

    const files: string[] = [];

    async function scanDir(dirPath: string): Promise<void> {
      try {

        for (const entry of entries) {

          if (entry.isDirectory() && !excludeDirs.includes(entry.name)) {
            await scanDir(fullPath);
          } else if (entry.isFile() && extensions.some(ext => entry.name.endsWith(ext))) {
            files.push(fullPath);
          }
        }
      } catch {
        // Directory not accessible, skip
      }
    }

    await scanDir(this.projectRoot);
    return files;
  }

  private mapAuditSeverity(severity: string): 'low' | 'medium' | 'high' | 'critical' {
    switch (severity?.toLowerCase()) {
      case 'critical': return 'critical';
      case 'high': return 'high';
      case 'moderate': return 'medium';
      case 'low': return 'low';
      default: return 'medium';
    }
  }

  // Export scan results
  async exportResults(outputPath: string): Promise<void> {

      ...this.scanResults,
      scanDate: new Date().toISOString(),
      projectPath: this.projectRoot,
      scanVersion: '1.0.0'
    };

    await fs.writeFile(outputPath, JSON.stringify(results, null, 2));
    // }
}

// Export for use in other modules
export type { SecurityVulnerability, SecurityScanResult };